--- stomp.py	2007-09-26 12:02:36.000000000 +1000
+++ lib/python/stomp.py	2007-09-26 12:20:56.000000000 +1000
@@ -57,6 +57,7 @@
 import socket
 import sys
 import thread
+import threading
 import time
 import types
 
@@ -318,6 +319,9 @@
         self.__socket = None
         self.__current_host_and_port = None
 
+        self.__receiver_thread_exit_condition = threading.Condition()
+        self.__receiver_thread_exited = False
+
     #
     # Manage the connection
     #
@@ -334,10 +338,16 @@
     def stop(self):
         """
         Stop the connection. This is equivalent to calling
-        disconnect().
+        disconnect() but will do a clean shutdown by waiting for the
+        receiver thread to exit.
         """
         self.disconnect()
 
+        self.__receiver_thread_exit_condition.acquire()
+        if not self.__receiver_thread_exited:
+            self.__receiver_thread_exit_condition.wait()
+        self.__receiver_thread_exit_condition.release()
+
     def get_host_and_port(self):
         """
         Return a (host, port) tuple indicating which STOMP host and
@@ -367,10 +377,13 @@
         self.__send_frame_helper('UNSUBSCRIBE', '', self.__merge_headers([headers, keyword_headers]), [ ('destination', 'id') ])
         
     def send(self, message='', headers={}, **keyword_headers):
-        self.__send_frame_helper('SEND', message, self.__merge_headers([{'ack': 'auto'}, 
-                                                                  headers, 
-                                                                  keyword_headers,
-                                                                  {'content-length': len(message)}]), [ 'destination', 'ack' ])
+        if '\x00' in message:
+            content_length_headers = {'content-length': len(message)}
+        else:
+            content_length_headers = {}
+        self.__send_frame_helper('SEND', message, self.__merge_headers([headers, 
+                                                                        keyword_headers,
+                                                                        content_length_headers]), [ 'destination' ])
     
     def ack(self, headers={}, **keyword_headers):
         self.__send_frame_helper('ACK', '', self.__merge_headers([headers, keyword_headers]), [ 'message-id' ])
@@ -393,10 +406,10 @@
     def disconnect(self, headers={}, **keyword_headers):
         self.__send_frame_helper('DISCONNECT', '', self.__merge_headers([headers, keyword_headers]), [ ])
         self.__running = False
+        self.__socket.shutdown(socket.SHUT_RDWR)
         self.__socket.close()
         self.__current_host_and_port = None
 
-
     # ========= PRIVATE MEMBERS =========
 
 
@@ -473,6 +486,7 @@
                                         reduce(lambda accu, key: accu + ('%s: %s\n' % (key, headers[key])), headers.keys(), ''),
                                         payload)        
             self.__socket.sendall(frame)
+            log.debug("Sent frame: type=%s, headers=%r, body=%r" % (command, headers, payload))
         else:
             raise NotConnectedException()     
 
@@ -480,47 +494,61 @@
         """
         Main loop listening for incoming data.
         """
-        while self.__running:
-            self.__attempt_connection()
-
-            if self.__socket is None:
-                return
-
+        try:
             try:
-                try:
-                    for listener in self.__listeners:
-                        listener.on_connecting(self.__current_host_and_port)
+                threading.currentThread().setName("StompReceiver")
+                while self.__running:
+                    self.__attempt_connection()
 
-                    while self.__running:
-                        frames = self.__read()
+                    if self.__socket is None:
+                        break
 
-                        for frame in frames:
-                            (frame_type, headers, body) = self.__parse_frame(frame)
-                            log.debug("Received frame: result=%s, headers=%s, body=%s" % (frame_type, headers, body))
-                            frame_type = frame_type.lower()
-                            if frame_type in [ 'connected', 
-                                               'message', 
-                                               'receipt', 
-                                               'error' ]:
-                                for listener in self.__listeners:
-                                    eval('listener.on_%s(headers, body)' % frame_type)
-                            else:
-                                log.warning('Unknown response frame type: "%s" (frame length was %d)' % (frame_type, len(frame)))
-                finally:
                     try:
-                        self.__socket.close()
-                    except:
-                        pass # ignore errors when attempting to close socket
-                    self.__socket = None
-                    self.__current_host_and_port = None
-            except ConnectionClosedException:
-                log.error("Lost connection")
-                # Notify listeners
-                for listener in self.__listeners:
-                    listener.on_disconnected()
-                # Clear out any half-received messages after losing connection
-                self.__recvbuf = ''
-                continue
+                        try:
+                            for listener in self.__listeners:
+                                listener.on_connecting(self.__current_host_and_port)
+
+                            while self.__running:
+                                frames = self.__read()
+
+                                for frame in frames:
+                                    (frame_type, headers, body) = self.__parse_frame(frame)
+                                    log.debug("Received frame: result=%r, headers=%r, body=%r" % (frame_type, headers, body))
+                                    frame_type = frame_type.lower()
+                                    if frame_type in [ 'connected', 
+                                                       'message', 
+                                                       'receipt', 
+                                                       'error' ]:
+                                        for listener in self.__listeners:
+                                            eval('listener.on_%s(headers, body)' % frame_type)
+                                    else:
+                                        log.warning('Unknown response frame type: "%s" (frame length was %d)' % (frame_type, len(frame)))
+                        finally:
+                            try:
+                                self.__socket.close()
+                            except:
+                                pass # ignore errors when attempting to close socket
+                            self.__socket = None
+                            self.__current_host_and_port = None
+                    except ConnectionClosedException:
+                        if self.__running:
+                            log.error("Lost connection")
+                            # Notify listeners
+                            for listener in self.__listeners:
+                                listener.on_disconnected()
+                            # Clear out any half-received messages after losing connection
+                            self.__recvbuf = ''
+                            continue
+                        else:
+                            break
+            except:
+                log.exception("An unhandled exception was encountered in the stomp receiver loop")
+
+        finally:
+            self.__receiver_thread_exit_condition.acquire()
+            self.__receiver_thread_exited = True
+            self.__receiver_thread_exit_condition.notifyAll()
+            self.__receiver_thread_exit_condition.release()
 
     def __read(self):
         """
